select 컬럼명 from 테이블명
select * from city where CountryCode = 'KOR';
인데 ' '이건 문자열
select * from city where Population >= 1000000;

조회할 때는 select를 쓴다.
select * from city where name like 'seo%'; : 유추할 때 쓰는거 (문자열 검색)
뒤애 두 글자가 있으면 __언더바를 친다 -> _ _ _ _
select * from city where name like 'seo__';

등록은 insert (추가)
insert into 테이블명 () values ();
insert into city (id, name, CountryCode, District, Population) values (4080, 'intec', 'KOR', 'incheon', 16);

수정 (수정이랑 삭제는 where문 필수!)
update 테이블 명 set 조건 where 
update city set population = 20 where id = 4080;

삭제
delete from 테이블 명
delete from city where Countrycode = 'KOR'

일본은 JPN
중국은 CHN
--------------------------------------------
DBever툴 -> MySQL -> 포트3306
------------DBeaver 툴에서 -------------
테이블 생성 create 
-> PK 생성 alter 
-> PK 속성 변경 (AutoIncrement) alter 
-> FK 생성  alter

--------------------------------------------
1. application.propertice -> 설정정보, 
2. build.gradle -> 환경설정 -> 라이브러리를 가져올때 쓰는거

구글링 -> " spring boot MySQL 연동 "이라고 치면 나옴

[application.properties 에서]
server.port = 원하는 포트로

순서 중요
Controller -> service -> mapping -> DB

DTO : data transfer object -> 데이터 전송 객체

클라이언트 --[REST-API]--> 서버

정상이 200
400번대는 클라이언트 오류 - NOT FOUND url이나 api url를 잘못 요청하였을 때
500번대는 서버 오류 - (톰갯로그 확인할 것)

http://localhost:8080/find

byte - short - int - long - float

부모 -> 자식 이럴때 자동변환이 됨

1. SRP : 단일 책임 원칙 -> 한 클래스는 하나의 책임만 가져야 한다.
2. OCP : 개방-폐쇄 원칙 -> 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다, 다형성 활용, 역할과 구현 분리
3. LSP : 리스코프 치환 원칙 -> 역할대로 인터페이스를 구현해줘야 함
4. IPS : 인터페이스분리 원칙 -> 인터페이스를 여러 개로 나눌것 (구현과 수정이 편함)
5. DIP : 의존관계 역전 원칙 -> 개발자는 추상화에 의존해야지, 구체화에 의존하면 안된다, 양쪽 모둘 모두 추상화에 의존해야 한다는 원칙, 역할만 바라볼 것, 클라이언트 - 인터페이스

IOC (Inversion of Control) : 스프링이 관리하는 공간, 객체(Bean)들을 등록할 수 있는 공간 

Lombok : Java의 라이브러리로 반복되는 메서드를 Annotation을 사용해 자동으로 작성해주는 편한 라이브러리

@NoArgsConstructor : 기본 생성자를 생성

@RequiredArgsConstructor : final 키워드 생성
